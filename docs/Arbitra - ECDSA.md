### Elliptic Curve Digital Signature Algorithm

To sign messages in Arbitra, we are going to use the Elliptic Curve Digital Signature Algorithm, or ECDSA. As previously explained, Digital Signatures  are a way of verifying that a message was sent from someone, by including a private key that can only have been generated by the private key, which only the sender should know. We can use a mathematical concept called *Elliptic Curves* to sign the messages in Arbitra.

Rather than using the Node.js `crypto` module's implementation, I decided to implement it myself, so I understand what's happening behind the scenes. I found a paper called *Implementation of Elliptic Curve Digital Signature Algorithm*, which provides some insight into the mathematics behind ECDSA, as well as an article called *Understanding How ECDSA Protects Your Data*. The best article I found was called *Elliptic Curve Cryptography: a gentle introduction*, as it covers the mathematics in depth enough to implement, but not assuming prior knowledge as the majority of other articles did, as well as providing Python examples of some algorithms.

https://pdfs.semanticscholar.org/c06a/d6512775be1076e4abd43e3f2928729da776.pdf

http://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/

http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/

##### Disclaimer

The reason I decided to implement ECDSA myself is that I could not figure out how to do it in the `crypto` module, and when I realised how to do it by that point I'd already done way too much research to back down. Still, it has proved a valuable learning experience.

#### Elliptic Curves

Elliptic curves are curves of the form $y^2=ax^3+bx+c$.

![some curves from wikimedia](https://upload.wikimedia.org/wikipedia/commons/d/db/EllipticCurveCatalog.svg)

But how does this relate to cryptography?

From http://wstein.org/edu/2007/spring/ent/ent-html/node89.html:

> Suppose $E$ is an elliptic curve over $\mathbb{F}_p$ and $P\in E(\mathbb{F}_p)$. Given a multiple $Q$ of $P$, the *elliptic curve    discrete logarithm problem* is to find $ n\in\mathbb{Z}$ such that $nP=Q$.

This means that it's really hard to find $n$ when you only have $Q$ and $P$- so hard, that we can use this problem to prove mathematically that $Q$ has been generated by $n$. This is how we sign messages in Arbitra - it shows that the message has to have been signed by the person who has the secret key.

However, before we start that we need to understand the operations we can perform on points on the curve, which is different to normal arithmetic. There are some operations we can perform:

- point addition
- point doubling

##### Point Addition

Point addition is the process of adding two points together to find a third. This is best shown by this [interactive Desmos graph](https://www.desmos.com/calculator/ialhd71we3).

![desmos point addition](https://i.imgur.com/1Z76fE3.png)

To add two points, you draw a straight line between them, and then find the negative of the third root when this line meets the curve.

This is very simple to calculate graphically, and relatively simple to calculate with pen and paper. However, to create a function we will need to create a formula using $x_1, y_1$ and $x_2, y_2$. 

It would be easier to just have to input $x_1$ and $x_2$ and for the function to calculate the corresponding $y$ values. Using the curve $y^3 = x^3 + 7$, we can find them using:
$$
y = \sqrt{x^3 + 7}
$$

###### Finding the line between a and b

To find the equation of the line between the points, we need to find the gradient of the line, which is given by:
$$
m = \frac{y_2 - y_1}{x_2 - x_1}
$$
The equation of the line is of the form $y = mx + c$, and since we have values for $x_1$, $y_1$, and $m$, we can rearrange to find $c$:
$$
c = y_1 - mx_1
$$
This is the $y$-intercept of the straight line.

###### Finding the third point

$y_3$ is given by:
$$
y_3 = mx_3 + c
$$
We need to find $x_3$. We can use:
$$
x_3 = m^2 - x_1 - x_2
$$
The point we are trying to find is therefore given by:
$$
(x_3, -y_3)
$$

###### Python Implementation

I wrote this into a Python function, where the curve is $y^2 = x^3 + 7$

```python
import math

def addPoints(x1, x2):
    # adding two points on an elliptic points
    y1 = math.sqrt(x1**3 + 7)
    y2 = math.sqrt(x2**3 + 7)
    # m is the gradient of the line between the points
    m = (y1-y2)/(x1-x2)
    # c is the y intercept
    c = y1 - m*x1
    x3 = m**2 - x1 - x2
    y3 = m*x3 + c
    return x3, -y3
```

From the interactive Desmos graph, inputting $x$ values of 1 and 3 gave $(-1.746,1.294)$.

```
>>> addPoints(1,3)
(-1.7462112512353212, 1.2943565281332712)
```

The function works! It doesn't handle edge cases yet, but we'll cover that later.

##### Point Doubling

The second operation we can perform is point doubling. From this graph:

![point doubling from instructables.com](https://cdn.instructables.com/FYY/9P98/I48CA2K9/FYY9P98I48CA2K9.MEDIUM.jpg)

It looks as if point $2P$ is the negative of the second intercept of the tangent from point $P$. This makes sense, as $2P = P + P$, and doing point edition with the same point will result in the tangent of that point. Unfortunately, since we find the gradient of the line using $m = \frac{y_2 - y_1}{x_2 - x_1}$, if $(x_1,y_1)=(x_2,y_2)$ that would divide by zero. Therefore we need to differentiate $y = \sqrt{x^3 + 7}$ using the chain rule:
$$
\frac{dy}{dx} = \frac{1}{2} \times 3x^2 \times (x^3+7)^{-\frac{1}{2}}
$$

$$
m = \frac{3x^2}{2 \sqrt{x^3+7}}
$$

We can now implement this in Python - I just used the same `addPoints()` function for simplicity. Also more comments.

```python
import math

def addPoints(x1, x2):
    # for the line y^2 = x^3 + 7
    y1 = math.sqrt(x1**3 + 7)
    y2 = math.sqrt(x2**3 + 7)
    # m is the gradient of the line between them
    if x1 == x2: # if points are the same, find the tangent
        m = (3*(x1**2))/(2*math.sqrt((x1**3)+7))
    else: # otherwise find gradient normally
        m = (y1-y2)/(x1-x2)
    # y-intercept
    c = y1 - m*x1
    # finding 3rd point
    x3 = m**2 - x1 - x2
    y3 = m*x3 + c
    return x3, -y3
```

```
>>> addPoints(1,1)
(-1.71875, -1.386592203732996)
```

We can verify this result using this tool, from *Elliptic Curve Cryptography: a gentle introduction*, since it takes this into account while the other tool doesn't.

https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-add.html?px=1&py=2&qx=1&qy=2

Therefore this function works! Before we finish, I wanted to make sure we could easily change the curve, by changing it to $y = x^3 +ax + b$. This means that we have to recalculate some of the maths, most notably the tangent equation:
$$
m = \frac{3x^2 + a}{2 \sqrt{x^3+ax+b}} = \frac{3x^2 + a}{2y}
$$
I also noticed we could simply the tangent equation given we know $y$ already. All the changes that were necessary to the python function were changing the differential and changing how it finds `y1` and `y2`.

```python
import math

def addPoints(x1, x2):
    # for the line y^2 = x^3 + 7
    a = 0
    b = 7
    y1 = math.sqrt(x1**3 + a*x1 + b)
    y2 = math.sqrt(x2**3 + a*x2 + b)
    # m is the gradient of the line between them
    if x1 == x2: # if points are the same, find the tangent
        m = (3*(x1**2)+a)/(2*y1)
    else: # otherwise find gradient normally
        m = (y1-y2)/(x1-x2)
    # y-intercept
    c = y1 - m*x1
    # finding 3rd point
    x3 = m**2 - x1 - x2
    y3 = m*x3 + c
    return x3, -y3
```

When `a = 0` and `b = 7` it gives the same results:

```
>>> addPoints(1,3)
(-1.7462112512353212, 1.2943565281332712)
>>> addPoints(1,1)
(-1.71875, -1.386592203732996)
```

With `a = -7` and `b = 10`, it gives:

```
>>> addPoints(1,3)
(-3.0, 2.0)
>>> addPoints(1,1)
(-1.0, -4.0)
```

Which can be verified with the tool:

https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-add.html?px=1&py=2&qx=1&qy=2

###### Point at Infinity

> What happens if the line doesn't intersect with the curve

If the line does not intersect, we say that it intersects the point at infinity, $O$. This only happens if you try to double $P$ where $y_P = 0$. However, this is not critically important at this phase, although we will have to add this in as an exception when creating the real function later on, as it will break the function (which is not good).

##### Point Multiplication

Now that we can do the basic function, we need to be able to multiply points, as we need to get to the stage where we can calculate $nP = Q$. The obvious way would be to double $P$, and then calculate $\text{Ans} + P$ for $n$ number of times. However, as *Elliptic Curve Cryptography: a gentle introduction* points out, this equation has an efficiency of $O(n)$, which is not particularly fast. However, they suggest using the **double and add** method to multiply points.

http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#scalar-multiplication

In summary, if you repeatedly double $P$, you would get the pattern:
$$
P, 2P, 2^2P, 2^3P, 2^4P, 2^5P...
$$
And we can can represent a decimal number in the following form:
$$
20_{10} = 10100_2
$$

$$
20 = 1 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 0  \times 2^2 + 0  \times 2^0
$$

$$
20 = 2^5 + 2^3
$$

Therefore:
$$
20P = 2^5P + 2^3P
$$
Since we can find $2^nP$ using point doubling, and since we can represent a large number very easily using binary, we can massively cut down on the calculations needed to multiply a point. In our example, five doublings and one addition is needed to find $20P$ and in the article, they show that only seven doublings and four additions are needed to find $151P$. This brings the complexity down to $O(\log n)$, which is much faster for larger numbers.

![algorithmic complexity graph](https://i.stack.imgur.com/WcBRI.png)

We can implement this in python (note that this is without looking at the given example code):

```python
def multiPoints(n,P):
    a = 0
    b = 7
    # find binary equivlent of n
    # and take the first 3 digits off
    nb = str(bin(n))[3:]
    total = P
    # and reverse it
    for bit in nb[::-1]:
        P,y = addPoints(P,P)
        if bit == "1":
            total,y = addPoints(total,P)
    return total, math.sqrt(total**3 + a*total + b)
```

The reason that it takes the first three digits off of the binary string is that they firstly are not of fixed length, so always start with 1, and secondly begin with `0b`. Knowing this, we can remove the first 3 digits and set total to start with the value $2^0P$.

This gives:

```
>>> multiPoints(5,5)
(-1.562727156221965, 1.7842754133340577)
```

We can verify this with this calculator:

https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-mul.html

Unfortunately it does not work, and it turns out the reason is that I made a logical error in the code. Even though the first digit of the binary sequence is always $1$, because that is the most significant bit it is actually the last number we want. The least significant bit, $2^0P$, can be $1$ or $0$, and so the corrected code looks like this (with total now initialising to $0$ and the loop rearranged):

```python
def multiPoints(n,P):
    a = 0
    b = 7
    # find binary equivlent of n
    # and take the first 2 and last digits off
    # first 2 are "0b" and last is definitly a 1
    nb = str(bin(n))[2:]
    total = 0
    # and reverse it
    for bit in nb[::-1]:
        if bit == "1":
            if total:
                total,y = addPoints(total,P)
            else:
                total = P
        P,y = addPoints(P,P)
    return total, math.sqrt(total**3 + a*total + b)
```

Strangely enough, this doesn't work for some numbers, but still does for others - looping though 0 to 24 produces the correct answers for 1, 2, 3, 4, 8, 9, 10, 11, 16, 17, 18, 19, and 24 (with the caveat that the y value is always positive because of the square root), but incorrect answers for the rest. Why is that? For 0 it is because there is starts at zero when it should start at infinity - that will be fixed. But the rest are strange, especially considering that it starts getting numbers incorrect, but then starts being correct again, which should not be possible considering each number relies on the previous one.

On top of this, it forms a sequence of 4 correct, 3 wrong, 4 correct, 4 wrong, which is very odd.

I decided to map out 1 to 10, with their binary equivalent, the answer the function gave, and the answer the calculator gave.

| Decimal | Binary | Function            | Calculator | Correct? |
| ------- | ------ | ------------------- | ---------- | -------- |
| 1       | 1      | 5                   | 5          | Yes      |
| 2       | 10     | 0.6534090909090917  | 0.6534     | Yes      |
| 3       | 11     | -1.562727156221965  | -1.56275   | Yes      |
| 4       | 100    | -1.250473444973121  | -1.25046   | Yes      |
| 5       | 101    | -1.5627271562219653 | 1.07934    | No       |
| 6       | 110    | 0.6534090909090918  | 7.3407     | No       |
| 7       | 111    | 5.000000000000002   | 169.37407  | No       |
| 8       | 1000   | 3.5915053505509373  | 3.59139    | Yes      |
| 9       | 1001   | 0.24372294383777238 | 0.24367    | Yes      |
| 10      | 1010   | -1.7888421516340784 | -1.78888   | Yes      |

Some observations:

- When it becomes incorrect, it repeats previous values. I have not seen a pattern in how it repeats itself.
- With some exceptions, when it breaks one of the correct values is often greater than about 12.

###### The Pattern

I noticed that when it started to go wrong, it was after the previous `x` value was negative, which I confirmed using the calculator. What could cause this? Of course, the usual answer is something to do with square roots. If we look at the `addPoints()` function:

```python
def addPoints(x1, x2):
    # for the line y^2 = x^3 + 7
    a = 0
    b = 7
    y1 = math.sqrt(x1**3 + a*x1 + b)
    y2 = math.sqrt(x2**3 + a*x2 + b)
    # m is the gradient of the line between them
    if x1 == x2: # if points are the same, find the tangent
        m = (3*(x1**2)+a)/(2*y1)
    else: # otherwise find gradient normally
        m = (y1-y2)/(x1-x2)
    # y-intercept
    c = y1 - m*x1
    # finding 3rd point
    x3 = m**2 - x1 - x2
    y3 = m*x3 + c
    return x3, -y3
```

There it is - calculating `y1` and `y2` uses `math.sqrt()`. This effectively means that it only adds points above the line $y=0$. We need to work around the square root in order for the algorithm to work in all cases.

###### The Solution

The solution is probably to not calculate the `y` values in this function. Instead both the `x` value and the `y` value should be passed to the function. The best way to do this is to group points into a tuple like so: `point = (4,6)`. Then when we want to get those variables back:

```python
x, y = point
# x is 4, y is 6
```

Alternatively we could use a list or even an object, but this is probably the simplest way.

Since I will soon be rewriting this function, I won't make changes here. As shown previously, the algorithm gets back on course after encountering a negative x value, so the `multiPoint()` function itself seems to work pretty well. All that is left to do is to add exceptions for multiplying by $0$, which I will do later on.

At this point, we can now find $nP = Q$. However, notice that we have no "point subtraction" or "point division". What if we wanted to find $n$ (the private key) from $Q$ and $P$? That is the *logarithm problem*, and the point of doing all this is to make that as hard as possible - the harder it is, the more secure the algorithm is. The next step is to make it even more difficult to find $n$.

#### Finite Fields

The way that ECDSA makes it harder is by using finite fields, which limits the number of elements we have. This makes the curve into a finite number of discrete points, and should make it much harder to find $n$. The problem, as stated at the beginning of the ECDSA section, is the *discrete logarithm problem*.

To restrict to a finite field, we use modular arithmetic.

In summary, the modulus operation finds the remainder when dividing one number by another. There are five different operations we can do:

- $(A+B)\bmod C = (A\bmod C + B\bmod C)\bmod C$
- $(A-B)\bmod C = (A\bmod C - B\bmod C)\bmod C$
- $(A \times B)\bmod C = (A\bmod C \times B\bmod C)\bmod C$
- $(A^B)\bmod C = ((A\bmod C)^B)\bmod C$
- $(A \times A^{-1})\bmod C = 1$

The last one is called the modular inverse, and is the most important. It is the equivalent of a modular division, because multiplying by an inverse number is the same as dividing by a non-inverse number.
$$
\frac ab = a \times b^{-1}
$$
Modular addition, subtraction, multiplication and exponentiation can all be calculated using Python's modulus operator `%`. We can also find the quotient without the remainder using `//`.

```
>>> 20/7
2.857142857142857
>>> 20//7
2
>>> 20%7
6
```

However, there is no built-in find the inverse mod of a number, so we need to implement our own algorithm. The naïve approach would be to iterate through possible values of $A^{-1}$ (also known as $k$).

```python
def slow_inv_mod(n,p):
    for i in range(p):
        if (n*i)%p == 1:
            return i
    raise ValueError(str(p)+" is not prime")
```

Unfortunately that runs slowly at $O(p)$. We need a more efficient algorithm, and for that we need to implement the Extended Euclidean Algorithm, which has a complexity of $O(\log (p)^2)$. It takes in two numbers $a$ and $b$, and returns $x$ and $y$ that satisfy the equation:
$$
ax + by = gcd(a,b)
$$
Where $gcd(a,b)$ is the greatest common divisor of the two numbers.

##### Implementing Modular Inverse 

We can calculate the $gcd$ easily using recursion:

```python
def gcd(a, b):
    if a and b:
        return gcd(b,a%b)
    else:
        return a or b
```

For example:

```
>>> gcd(270,192)
6
```

However, the algorithm itself works differently.

Implementing the pseudocode found on Wikipedia:

https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode

```python
def eec(a,b):
    x, old_x = 0, 1
    y, old_y = 1, 0
    r, old_r = b, a

    while r != 0:
        quot = old_r // r
        old_r, r = r, old_r - quot * r
        old_x, x = x, old_x - quot * x
        old_y, y = y, old_y - quot * y
	
    # ax + by = gcd(a,b)
    # returns (gcd, x, y)
    return old_r, old_x, old_y
```

Since [Wikipedia was kind enough to provide a trace table](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example) of the algorithm, we can confirm that it works. For the input $240$, $46$, we expect the values $2$, $-9$, $49$.

```
>>> eec(270,192)
(2, -9, 47)
```

We can further confirm that the $gcd$ is 2 using the `gcd()` function.

```
>>> gcd(270,192)
2
```

Now for the actual inverse modulus function. Something to mention at this point is that $p$ must be a prime number. This is because $gcd$ must be equal to $1$ so  that it can be used in the modular inverse function - in fact, $N$ *only* has an inverse if $gcd = 1$.

```python
def invMod(n,p):
    gcd, x, y = eec(n,p)
    if gcd == 1:
        return x%p
    else:
        raise ValueError(str(p)+" isn't prime (or n = 0)")
```

Whilst this seems too simple to be correct, as far as I can tell that is all that is needed, since if $k$ is the inverse of $N$:
$$
(N \times k)\bmod p = 1
$$
and we know that this equation is equal to $1$ if $p$ is prime:
$$
Nx + py = gcd(N,p) = 1
$$
therefore if we find the $\bmod p$ of all values:
$$
(N \times x)\bmod p + (p \times y)\bmod p = 1\bmod p
$$
and since $1\bmod p = 1$ and $(n\times C)\bmod C = 0$:
$$
(N \times x)\bmod p = 1
$$
This is the same form as the modular inverse. Now all we need to do is find $x\bmod p$ so that we can then later use it in the form $(A \times B)\bmod C = (A\bmod C \times B\bmod C)\bmod C$ (or similar).

Now we have this algorithm down, it is time to explore the implications of $\bmod p$.

##### mod p

If you were to find the modulus of all real numbers - $\mathbb{R}\bmod n$ - you would be splitting up $\mathbb{R}$ into $n$ groups.

Here is $\mathbb R \bmod 5$:

![mod 5](https://ka-perseus-images.s3.amazonaws.com/2b71fee76257ba0bdc1e4b2b64249abe7e30c2d5.png)

Image from Khan Academy: https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/congruence-modulo

When we do that, it is known as a Finite Field, and is represented as $\mathbb F_n$. It contains all integers from $0$ to $n$. In the above example, that is the finite field $\mathbb F_5$, and contains $0$, $1$, $2$, $3$, $4$. Whilst this doesn't seem too useful, we can still do maths on it - except instead of normal arithmetic, we use the modular arithmetic. For example, if we wanted to do $3+4$ in $\mathbb F_5$, we would have to do $5+4 \pmod 5$, which is $4$.

###### Side note regarding notation

Whilst previously I had been using $(A+B)\bmod C$, I will now be switching to $A+B \pmod C$, because it indicates that it's all modulus $C$, which will be the case from now on.

###### Graphs and mod p

The most important thing about curves in $\mathbb F_p$ is that instead of being a continuous line, they become a bunch of discrete points. The bigger that $p$ is, the more points there are. The axis also only goes from $0$ to $p-1$ (therefore "finite field"), as you can see in these graphs:

![mod 541](http://slideplayer.com/slide/4377224/14/images/21/Elliptic+Curve+mod+p.jpg)

Something else important to understand about modulus is how it "wraps around". If we were to find $65536\pmod 5$, it doesn't matter that $65536>5$ as it just removes $5$ over and over until the resulting number is less than $5$, which is the remainder. That is why it is know as "clock arithmetic", because if you wanted to find the time 50 hours after 2pm, you would go around the clock until the resulting number is less than 24. We can therefore represent this problem as $2+50\pmod{24}$, which is $4$, and therefore 4am.

This means that a plane in the $x,y$ axis in the finite field $\mathbb F_p$ would only go from $0$ to $p-1$, but when a line in the graph reaches the edge of the plane it wraps around to the other side.

This means that we can still add and multiply points, as visually demonstrated in this calculator:

https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/modk-add.html

However, we now need to update our point adding function. Instead of adding points on the curve $y^2 = x^3 +ax +b$, it now needs add points on the curve $y^2 = x^3 +ax +b \pmod p$. This basically includes adding `%p` to the end of all our functions, but we need to make some deeper changes (for example to account for the point at infinity)

Before we start, two things:

1. $p$ is a prime number. This is because when $p$ isn't prime, some points can often overlap, and we also can't find the modular inverse.
2. $p$ is very, very big when doing cryptography. In the `secp256k1` curve, for example, $p = 2^256 - 2^32 - 977$.

$p$ can just be an argument passed to the function in this case.

Since we will need to remake most of the functions that we've made so far, I decided to take this opportunity to clean up the code a bit. To start, I made a `elliptic_curve` class so that we can define $a$, $b$ and $p$ once, and then use `ec.p` (for example) if we wanted $p$.

```python
class elliptic_curve():
    def __init__(self,a,b,p):
        self.a = a
        self.b = b
        self.p = p

ec = elliptic_curve(0,7,97)
```

In this example, we have made the curve $y^2 = x^3 + 7 \pmod{97}$ .

Next, we need to think about how the `addPoints()` function works. First of all, we need to take into account the changes mentioned in the point multiplication section - passing both co-ordinates of the points.

```python
def addPoints(P1,P2):
    x1,y1 = P1
    x2,y2 = P2
```

Second of all, we need to make sure that the points are actually on the curve - previously, we dealt with that by only requiring one value. Now, we have to make sure the inputs make sense. To do this, we will make a new function that makes sure that $y^2 - x^3 - ax -b = 0 \pmod p$ by raising a `ValueError` if it doesn't:

```python
def onCurve(point):
    x,y = point
    if (y**2 - x**3 - ec.a*x - ec.b) % ec.p != 0:
        raise ValueError("({},{}) is not on the curve".format(x,y))
```

Now `addPoints()` looks like this:

```python
def addPoints(P1,P2):
    # make sure they're on the curve
    onCurve(P1)
    onCurve(P2)
    
    x1,y1 = P1
    x2,y2 = P2
```

Now we need to account for the $\pmod p$. This is simple enough.

```python
	...    
    # need to define m
    
    x3 = (m**2 - x1 - x2) % ec.p
    y3 = (y1 + m*x3 - m*x1) % ec.p
```

However, we need to find the gradient, and there we have a problem.
$$
m = \frac{y_2 - y_1}{x_2 - x_1} \text{ or } m = \frac{3x^2 + a}{2y}
$$
Both these equations have a division in them, and we can't do that!

We need to rearrange them like so:
$$
m = (y_2 - y_1)(x_2 - x_1)^{-1} \text{ or } m = (3x^2 + a)(2y)^{-1}
$$
Now we can use our inverse modulus algorithm.

```python
def addPoints(P1,P2):
	...
	# finding gradient
	if x1 == x2:
		m = ((3*(x1**2)+3)*invMod(2*y1,ec.p))
	else:
		m = ((y2 - y1)*invMod(x2-x1,ec.p))
    
	x3 = (m**2 - x1 - x2)
	y3 = (y1 + m*x3 - m*x1)
```

Finally, we can the resultant point.

```python
def addPoints(P1,P2):
	# make sure they're on the curve
    onCurve(P1)
    onCurve(P2)
    
    x1,y1 = P1
    x2,y2 = P2
	# finding gradient
	if x1 == x2:
		m = ((3*(x1**2)+3)*invMod(2*y1,ec.p))
	else:
		m = ((y2 - y1)*invMod(x2-x1,ec.p))
    
	x3 = (m**2 - x1 - x2) % ec.p
	y3 = -(y1 + m*x3 - m*x1) % ec.p
    P3 = (x3,y3)
    onCurve(P3)
    
    return P3
```

This should work in most cases, but we're missing something - the point at infinity.

###### Things we know about the point at infinity

- It's the third point if the line between two points doesn't intersect a third time
- $O + \text{point} = \text{point}$
- $O = -O$
- $\text{point} + -\text{point} = O$ (which can be visualized by drawing a straight vertical line line through the curve)

The most important point here is $O + \text{point} = \text{point}$ - that means we can just return `P1` if `P2 == O`, and vice versa. It also means that if `x1 == x2` but `y1 != y2`, the third point is $O$.

The thing to notice in all these points is that none of these require $O$ to be an actual number, as if it is passed to the function, it returns something before the maths starts. Therefore, I have decided for $O$ to be the string `"infinity"`, so it definitely cannot be confused, and will throw a `TypeError` if I make a mistake and it manages to get through to the maths.

With this in mind, I created the final function:

```python
def addPoints(P1,P2):
    # make sure they're on the curve
    onCurve(P1)
    onCurve(P2)

    if P1 == "infinity":
        return P2
    elif P2 == "infinity":
        return P1

    x1,y1 = P1
    x2,y2 = P2

    # finding gradient
    if x1 == x2:
        if y1 != y2:
            return "infinity"
        else:
            m = ((3*(x1**2)+ec.a)*invMod(2*y1,ec.p))
    else:
        m = ((y2 - y1)*invMod(x2-x1,ec.p))

    x3 = (m**2 - x1 - x2) % ec.p
    y3 = -(y1 + m*x3 - m*x1) % ec.p
    P3 = (x3,y3)
    onCurve(P3)

    return P3
```

 I tested it out with the points $(5,36)$ and $(20,21)$, which I knew were on the curve thanks to the calculator:

```
>>> addPoints((5,36),(20,21))
(73, 32)
```

We can verify it with this calculator:

https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/modk-add.html

![adding points in Fp](https://i.imgur.com/9Rj6OQN.png)

It worked! It should now be simple to convert the point multiplication function.

```python
def multiPoints(n,P):
    onCurve(P)
    if P == "infinity":
        return P
    # find binary equivlent of n
    # and take the first digits off
    nb = str(bin(n))[2:]
    total = "infinity"
    # and reverse it
    for bit in nb[::-1]:
        if bit == "1":
            total = addPoints(total,P)
        P = addPoints(P,P)
    onCurve(P)
    return total
```

`multiPoints()` is now much simpler, because of two things:

1. Now that we properly support $O$, it starts `total` as $O$ which will give the correct answer, rather than manually setting `total` to the correct answer after the first run.
2. Passing points rather than $x$ values eliminates the problem we were having with negative values.

Now for testing:

```
>>> multiPoints(20,(20,21))
(62, 54)
```

Which we can verify with the calculator:

https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/modk-mul.html

It worked! This is all of the functions that we need to actually create signatures.

##### Objectifying

I decided to move all the functions into one class (`elliptic_curve()`), to make it simpler.

Here is the class in it's entirety:

```python
class elliptic_curve():
    def __init__(self,a,b,p):
        self.a = a
        self.b = b
        self.p = p
        
    def onCurve(self,point):
        if point != "infinity":
            x,y = point
            if (y**2 - x**3 - self.a*x - self.b) % self.p != 0:
                raise ValueError("({},{}) is not on the curve".format(x,y))
    
    def eec(self,a):
        x, old_x = 0, 1
        y, old_y = 1, 0
        r, old_r = self.p, a

        while r != 0:
            quot = old_r // r
            old_r, r = r, old_r - quot * r
            old_x, x = x, old_x - quot * x
            old_y, y = y, old_y - quot * y
        
        # ax + by = gcd(a,b)
        # returns (gcd, x, y)
        return old_r, old_x, old_y

    def invMod(self,n):
        gcd, x, y = self.eec(n)
        if gcd == 1:
            return x % self.p
        else:
            raise ValueError(str(p)+" isn't prime (or n = 0)")

    def addPoints(self,P1,P2):
        # make sure they're on the curve
        self.onCurve(P1)
        self.onCurve(P2)

        if P1 == "infinity":
            return P2
        elif P2 == "infinity":
            return P1

        x1,y1 = P1
        x2,y2 = P2

        # finding gradient
        if x1 == x2:
            if y1 != y2:
                return "infinity"
            else:
                m = ((3*(x1**2)+self.a)*self.invMod(2*y1))
        else:
            m = ((y2 - y1)*self.invMod(x2-x1))

        x3 = (m**2 - x1 - x2) % self.p
        y3 = -(y1 + m*x3 - m*x1) % self.p
        P3 = (x3,y3)
        self.onCurve(P3)
        return P3

    def multiPoints(self,n,P):
        self.onCurve(P)
        if P == "infinity":
            return P
        # find binary equivlent of n
        # and take the first digits off
        nb = str(bin(n))[2:]
        total = "infinity"
        # and reverse it
        count = 0
        for bit in nb[::-1]:
            if bit == "1":
                total = self.addPoints(total,P)
            P = self.addPoints(P,P)
        self.onCurve(P)
        return total
```

We don't even need to import `math` anymore.

All we need to do to interact with this class is create a curve:

```python
ec = elliptic_curve(0,7,97)
```

Then call the functions from that object:

```python
print(ec.multiPoints(5,(20,21)))
```

#### Back to Cryptography

Now that we have all the functions we need, we can soon start actually creating and verifying signatures!

However first, we need some finally things.

##### Picking a curve

I found the very useful website [http://safecurves.cr.yp.to]() (which has a very cool domain name) that has a list of many of the elliptic curves that have been found. It also rates their security based on several different factors. Interestingly `secp256k1`, the curve Bitcoin uses, is not rated as safe.

However, before we pick a curve, there is something that needs to be mentioned about curves - there are different kinds. All the work so far has been for **Weierstrass curves** - curves with the equation $y^2 = x^3 +ax +b$ that satisfy the equation $4a^3+27b^2 \neq 0$.

Elliptic curves can take other forms, such as the **Edwards curves** of the form $x^2 + y^2 = 1 + dx^2y^2$

Since using other curve forms would require redoing a lot of our maths, and converting from one curve type to another is very complex (I tried), I decided just to use a Weierstrass curve. Although none were deemed safe by [http://safecurves.cr.yp.to/](), I decided on `secp256k1`, which is defined as:
$$
y^2 = x^3+7 \pmod {115792089237316195423570985008687907853269984665640564039457584007908834671663}
$$
I chose `secp256k1` for several reasons:

- It is the curve that both Bitcoin, Ethereum, and Litecoin use
- The $a$ and $b$ values are very easy to remember
- Due to it's aforementioned popularity, there is far more resources for `secp256k1` than other curves, for example I was not able to find the subgroup order when trying to implement a different curve

##### Curve Characteristics

The characteristics of the curve are specified in this document, from the *Standards of Efficient Cryptography* group:

http://www.secg.org/sec2-v2.pdf

We don't just need the the $a$ and $b$ values for the curve, we also need some other values. First of all, we need the **Base Point** $G$. There is a specific value for each curve, and it's just a static number you can look up. So for `secp256k1` the base point is:
$$
x_G = 55066263022277343669578718895168534326250603453777594175500187360389116729240
$$

$$
y_G = 32670510020758816978083085130507043184471273380659243275938904335757337482424
$$

But what is the base point? A base point generates a subgroup - a subsection of the points on the curve. If you find the multiples of a point, it generates a group of coordinates that eventually loops back on itself.

The **order** of a group is the number of points in it. The number of points in the curve as a whole is it's order, $N$.

Therefore the **subgroup order** $n$ is the number of points in the subgroup created by our base point. For `secp256k1`:
$$
n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
$$
Finally there is the subgroup cofactor, which is just $h = 1$. I don't believe this will come up in the calculations.

We can add these characteristics to our Python class:

```python
ec = elliptic_curve(0,7,115792089237316195423570985008687907853269984665640564039457584007908834671663,(55066263022277343669578718895168534326250603453777594175500187360389116729240,32670510020758816978083085130507043184471273380659243275938904335757337482424),115792089237316195423570985008687907852837564279074904382605163141518161494337)
```



##### Creating a signature

Finally, we have all the information to start signing stuff!

First off, what we're signing needs to be the same bit length as $n$, the subgroup order. Since we hash the messages using `sha256`, and we're using the curve `secp256k1`, they both have the same big length of, unsurprisingly, 256. The message we're signing is denoted as $z$.

We also need a public key and a private key. The private key $w$ is a random integer chosen from $\{1,...,n-1\}$, and the public key $q = wG$ using the scalar multiplication function. I created a Python function to create these:

```python
    def createKeys(self):
        private = randrange(1,self.n)
        public = self.multiPoints(private,self.g)
        return (private,public)
```

`randrange()` is from the `random` module, which I imported at the top of the program using `from random import randint`.

To create a signature, we need to follow these instructions:

1. Choose a random integer $k$ chosen from $\{1,...,n-1\}$
2. Calculate  the point $P = kG$
3. Calculate $r = x_P \pmod{n}$ where $x_P$ is the $x$ value of $P$
4. If $r = 0$, start again with a different value of $k$
5. Calculate $s = k^{-1} (z + rw) \pmod{n}$
6. If $s = 0$, start again with a different value of $k$

From http://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/

The signature is then $(r,s)$.

Implementing that in Python, as a part of the `elliptic_curve()` class:

```python
    def signMsg(self,msg,w):
        z = sha256(msg)
        while True:
            k = randrange(1,self.n)
            P = self.multiPoints(k,self.g)
            xP,yP = P
            r = xP % self.n
            if r != 0:
                s = (self.invMod(k)*(z + r*w) ) % self.n
                if s != 0:
                    return (r,s)
```

##### Verifying a signature

We also can now verify a signature.

From the same source, the method to verify a secret key is:

1. Calculate $u_1 = s^{-1} z \pmod{n}$
2. Calculate $u_2 = s^{-1} r \bmod{n}$
3. Find the point $P = u_1 G + u_2 H_A$
4. Find $x_P \pmod n$

If $r = x_P \pmod n$, then the signature is valid.

We can implement this in Python as well:

```python
    def verifyMsg(self,msg,signature,q):
        r,s = signature
        z = sha256(msg)
        u1 = (self.invMod(s)*z) % self.n
        u2 = (self.invMod(s)*z) % self.n
        x,y = self.addPoints(self.multiPoints(u1,self.g),self.multiPoints(u2,q))
        return r == x % self.n
```

##### Verifying the program

We need to test the program. At first, we will sign the string `"hello"`, and then verify it.

```python
public,private = ec.createKeys()

signature = ec.signMsg("hello",private)

print(ec.verifyMsg("hello",signature,public))
```

Unfortunately, this doesn't work.

```
Traceback (most recent call last):
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 121, in <module>
    signature = ec.signMsg("hello",private)
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 103, in signMsg
    s = (self.invMod(k)*(z + r*w))
OverflowError: cannot fit 'int' into an index-sized integer
```

It's a strange error that I've never had before.

It then occurred to me that this is the first time that `z` is operated on, and `z` is $z$, the hash. The hash, if you remember the function, returns the hash as a hex string. Presumably, this is what the error is referring to. I replaced the decimal inputs with hexadecimal inputs:

```python
# secp256k1
ec = elliptic_curve(
    0,
    7,
    0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f,
    (0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
    0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8),
    0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141)
```

It still didn't work. [I looked up the error](https://stackoverflow.com/questions/4751725/python-overflowerror-cannot-fit-long-into-an-index-sized-integer), and apparently it's an issue converting Python `int`s to a C integer. Since the change makes the code more readable, I decided to keep it regardless.

I split up the offending line to see which operation causes the error.

```python
                one = (z + r*w)
                two = self.invMod(k)
                s = (one*two) % self.n
```

```
Traceback (most recent call last):
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 128, in <module>
    signature = ec.signMsg("hello",private)
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 103, in signMsg
    one = (z + r*w)
OverflowError: cannot fit 'int' into an index-sized integer
```

Even more:

```python
                rw = r*w
                one = z + rw
```

```
Traceback (most recent call last):
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 129, in <module>
    signature = ec.signMsg("hello",private)
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 103, in signMsg
    rw = r*w
OverflowError: cannot fit 'int' into an index-sized integer
```

So clearly, `r * w` is causing an overflow error. I printed both values, and it turns out the `w` is `(105339730627913794384744097333103439091751005834042565437622273746527120460296, 57526216366140097205440521137091723264218019353485851044212924740410855711206)` - a point. This is probably the cause of the error. I looked at the `createKeys()` function, and it returns `(private,public)`. However, when we call it:

```python
public,private = ec.createKeys()
```

They're the wrong way round! We were passing the public key (a point) as the private key. Once I fixed it:

```
Traceback (most recent call last):
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 129, in <module>
    signature = ec.signMsg("hello",private)
  File "c:\Users\Mozzi\Documents\Programming\arbitra\ec.py", line 104, in signMsg
    one = z + rw
TypeError: Can't convert 'int' object to str implicitly
```

Now we have a new error, and it was the error that I thought caused the other one. `z` is the wrong type - we need it to be an integer. At the moment, it's just a string. I replaced all instances of `z = sha256(msg)` with:

```python
z = int(sha256(msg),16)
```

This should work:

```
False
```

Whilst it's not throwing errors anymore, it is also not the answer we want.

After a lot of checking, I realised that when we need to find $s = k^{-1} (z + rw) \pmod{n}$, we use the `invMod()` function. However, if we look at `invMod()`:

```python
    def invMod(self,n):
        gcd, x, y = self.eec(n)
        if gcd == 1:
            return x % self.p
        else:
            raise ValueError(str(p)+" isn't prime (or n = 0)")
```

It returns `x % self.p`, whereas we want `x % self.n`. To fix this, I changed both `invMod()` and `ecc()` to take both `n` and `p`, where `p` is the value we want for the modulus. The new code looks like this:

```python
    def eec(self,a,p):
        x, old_x = 0, 1
        y, old_y = 1, 0
        r, old_r = p, a

        while r != 0:
            quot = old_r // r
            old_r, r = r, old_r - quot * r
            old_x, x = x, old_x - quot * x
            old_y, y = y, old_y - quot * y
        
        # ax + by = gcd(a,b)
        # returns (gcd, x, y)
        return old_r, old_x, old_y
    def invMod(self,n,p):
        gcd, x, y = self.eec(n,p)
        if gcd == 1:
            return x % p
        else:
            raise ValueError(str(p)+" isn't prime (or n = 0)")
```

This new code is more correct. Unfortunately, the verify function still fails.

```
False
```

This is very inconvenient to debug, as it is almost impossible to tell what the correct answers should be.

After hours of debugging, checking every single function - and rewriting half of them - I found the issue.

The problem was... a typo.

```python
    def verifyMsg(self,msg,signature,q):
        r,s = signature
        z = int(sha256(msg),16)
        u1 = (self.invMod(s,self.n)*z) % self.n
        u2 = (self.invMod(s,self.n)*r) % self.n # r used to be z
        x,y = self.addPoints(self.multiPoints(u1,self.g),self.multiPoints(u2,q))
        return r % self.n == x % self.n
```

I forgot to change `u2` to take `r` instead of `z`. Finally, the function works:

```
True
```

We can check that it rejects incorrect messages:

```python
private,public = ec.createKeys()
signature = ec.signMsg("hello",private)
print(ec.verifyMsg("hello",signature,public))
print(ec.verifyMsg("bean",signature,public))
```

```
True
False
```

#### Conclusion

In this section, I built a working Elliptic Curve Digital Signature Algorithm in Python. This should allow me to easily convert to Javascript in the implementation phase.

I learnt a lot about the mathematics behind not just ECDSA, but also about finite fields and modular arithmetic.

From here, we need to design the application serves as an interface to Arbitra's functions.